/********************************************************************
* 文件名  ： 矩阵键盘.c
* 描述    :  该文件实现了 4 * 4 键盘的试验。通过数码管的最后两位来显示当前的按键值。		 
* 创建人  ： 东流，2009年4月9日
* 版本号  ： 2.0
* 技术支持论坛：www.zidh.com/bbs（请进入“赞助商板块”中的“东流电子工作室”）
* 感谢“中国自动化资讯网”对本工作室的大力支持。
*********************************************************************/
#include<ioCC2530.h>
//#include<intrins.h>

#define uint unsigned int
#define uchar unsigned char

uchar table[8] = {0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80};

/********************************************************************
* 名称 : Delay_1ms()
* 功能 : 延时子程序，延时时间为 1ms * x
* 输入 : x (延时一毫秒的个数)
* 输出 : 无
***********************************************************************/
void Delay_1ms(uint i)
{
	uchar x,j;
	for(j=0;j<i;j++)
	for(x=0;x<=148;x++);	
}

void InitKey(void)//初始化Key
{
	P0DIR &= 0x00;
	P0SEL &= 0x00;
	P2INP &= 0xd7;
	P0INP &= 0x00;
}

void InitLed(void)//初始化led
{
	P1DIR |= 0xff;
	//LedOnOrOff(1);
}
/********************************************************************
* 名称 : Keyscan()
* 功能 : 实现按键的读取。下面这个子程序是按处理 矩阵键盘 的基本方法处理的。
		 该函数的原理将在“视频及教程”文件夹中介绍。
* 输入 : 无
* 输出 : 按键值
***********************************************************************/
uchar Keyscan(void)
{
	uchar i,j, temp, Buffer[4] = {0xef, 0xdf, 0xbf, 0x7f};
	for(j=0; j<4; j++)
	{
		P1 = Buffer[j];
		/*以下三个_nop_();作用为让 P1 口的状态稳定*/
		// _nop_();
		// _nop_();
		// _nop_();
		temp = 0x01;                                                                                                                                                                    
		for(i=0; i<4; i++)
		{
			if(!(P1 & temp)) 
			{
				return (i+j*4);		  //返回取得的按键值
			}
			temp <<= 1;
		}	
	}
}

/********************************************************************
* 名称 : Main()
* 功能 : 主函数
* 输入 : 无
* 输出 : 无
***********************************************************************/
void main(void)
{
	uchar Key_Value;  //读出的键值		
	InitLed();
	InitKey();
	while(1)
	{
		P1 = 0xf0;		
		if(P1 != 0xf0)
		{
			Delay_1ms(15);	//按键消抖
			if(P1 != 0xf0)
			{
				Key_Value = Keyscan();		
			}
		}
		// P0 = table[Key_Value / 10];     //显示高位键值
		// P2 = 0x00;
		// Delay_1ms(5);       
		P0 = table[Key_Value % 10];		//显示低位键值
		// P2 = 0x04;
		Delay_1ms(5);
	}
}
